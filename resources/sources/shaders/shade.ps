#include "structures.h"
#include "layout.h"
#include "common.h"

StructuredBuffer<mesh_object>	g_mesh_objects		: register( t0 );
StructuredBuffer<uint>			g_indices			: register( t1 );
StructuredBuffer<float3>		g_vertices			: register( t2 );
StructuredBuffer<vertex_data>	g_vertex_data		: register( t3 );
StructuredBuffer<float4x3>		g_transforms		: register( t4 );
SamplerState					g_sampler			: register( s0 );

float3 compute_barycentrics( float3 ro, float3 rd, float3 a, float3 b, float3 c )
{
	const float3 dp0 = ro - a;
	const float3 dp1 = b - a;
	const float3 dp2 = a - c;

	const float3 dett = cross(dp1, dp2);
	const float3 detuv = cross(dp0, rd);

	float den = dot(dett, rd);

	float3 det = -1.0 / den;

	float3 bc = float3(0.0f, dot(detuv, dp2), dot(detuv, dp1)) * det;
	bc.x = 1.0 - bc.y - bc.z;

	return bc;
}

vertex_data_unpacked interpolate_vertex_data( vertex_data_unpacked v0, vertex_data_unpacked v1, vertex_data_unpacked v2, float3 barycentrics )
{
	vertex_data_unpacked data;

	data.texcoord = barycentrics.x * v0.texcoord + barycentrics.y * v1.texcoord + barycentrics.z * v2.texcoord;
	data.normal = barycentrics.x * v0.normal + barycentrics.y * v1.normal + barycentrics.z * v2.normal;

	return data;
}

void main(
	in	float4	in_position : SV_Position,
	out	float4	out_color	: SV_Target0
)
{
	const uint3 pixel_index = uint3( in_position.xy, 0 );
	const uint2 polygon_id = g_polygon_id.Load( pixel_index );

	const mesh_object mesh = g_mesh_objects[polygon_id.x];
	const float4x3 transform = g_transforms[mesh.transform_index];

	const uint i0 = load_u16( g_indices, mesh.index_buffer_offset + 3 * polygon_id.y + 0 );
	const uint i1 = load_u16( g_indices, mesh.index_buffer_offset + 3 * polygon_id.y + 1 );
	const uint i2 = load_u16( g_indices, mesh.index_buffer_offset + 3 * polygon_id.y + 2 );

	const float3 v0_local = g_vertices[i0];
	const float3 v1_local = g_vertices[i1];
	const float3 v2_local = g_vertices[i2];

	float3 v0 = mul( transpose( transform ), float4( v0_local, 1.0f ) );
	float3 v1 = mul( transpose( transform ), float4( v1_local, 1.0f ) );
	float3 v2 = mul( transpose( transform ), float4( v2_local, 1.0f ) );

	float2 screen_uv = in_position.xy * g_constant_buffer.viewport_size.zw;
	float3 world_camera_ray = screen_position_to_world_ray( screen_uv );
	
	float2 screen_uv_right = screen_uv + float2( g_constant_buffer.viewport_size.z, 0.0f );
	float3 world_camera_ray_right = screen_position_to_world_ray( screen_uv_right );
	
	float2 screen_uv_bottom = screen_uv + float2( 0.0f, g_constant_buffer.viewport_size.w );
	float3 world_camera_ray_bottom = screen_position_to_world_ray( screen_uv_bottom );

	const vertex_data_unpacked v0_info = unpack_vertex_data( g_vertex_data[i0] );
	const vertex_data_unpacked v1_info = unpack_vertex_data( g_vertex_data[i1] );
	const vertex_data_unpacked v2_info = unpack_vertex_data( g_vertex_data[i2] );

	const vertex_data_unpacked data = interpolate_vertex_data( v0_info, v1_info, v2_info, compute_barycentrics( g_constant_buffer.world_camera_position.xyz, world_camera_ray.xyz, v0.xyz, v1.xyz, v2.xyz ) );
	const vertex_data_unpacked data_right = interpolate_vertex_data( v0_info, v1_info, v2_info, compute_barycentrics( g_constant_buffer.world_camera_position.xyz, world_camera_ray_right.xyz, v0.xyz, v1.xyz, v2.xyz ) );
	const vertex_data_unpacked data_bottom = interpolate_vertex_data( v0_info, v1_info, v2_info, compute_barycentrics( g_constant_buffer.world_camera_position.xyz, world_camera_ray_bottom.xyz, v0.xyz, v1.xyz, v2.xyz ) );

	const float2 texcoord_ddx = data_right.texcoord.xy - data.texcoord.xy;
	const float2 texcoord_ddy = data_bottom.texcoord.xy - data.texcoord.xy;

	const float4 diffuse = g_textures[NonUniformResourceIndex(mesh.diffuse_texture_index)].SampleGrad( g_sampler, data.texcoord, texcoord_ddx, texcoord_ddy );
	const float4 specular = g_textures[NonUniformResourceIndex(mesh.specular_texture_index)].SampleGrad( g_sampler, data.texcoord, texcoord_ddx, texcoord_ddy );

	out_color = diffuse * 0.8f + specular * 0.2f;
}